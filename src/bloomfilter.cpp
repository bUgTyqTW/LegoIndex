#include <vector>

#include <geosindex/bloomfilter.h>

namespace geosindex {

    void BloomFilter::CreateFilter(const std::vector<uint64_t> &keys, std::string *dst) {
        size_t n = keys.size();
        // Compute bloom filter size (in both bits and bytes)
        size_t bits = n * bits_per_key_;

        // For small n, we can see a very high false positive rate.  Fix it
        // by enforcing a minimum bloom filter length.
        if (bits < 64) bits = 64;
        if (bits > max_bf_size_) bits = max_bf_size_;
        // size_t bits = max_bf_size_;
        size_t bytes = (bits + 7) / 8;
        bits = bytes * 8;

        const size_t init_size = dst->size();
        dst->resize(init_size + bytes, 0);
        dst->push_back(static_cast<char>(k_));  // Remember # of probes in filter
        char *array = &(*dst)[init_size];
        for (int i = 0; i < n; i++) {
            // Use double-hashing to generate a sequence of hash values.
            // See analysis in [Kirsch,Mitzenmacher 2006].
            std::hash<std::string> hashFunction;
            size_t h = hashFunction(std::to_string(keys[i]));
//            uint32_t h = BloomHash(keys[i]);
            const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
            for (size_t j = 0; j < k_; j++) {
                const uint32_t bitpos = h % bits;
                array[bitpos / 8] |= (1 << (bitpos % 8));
                h += delta;
            }
        }
    }

    bool BloomFilter::KeyMayMatch(const std::string &key, const std::string &bloom_filter) {
        const size_t len = bloom_filter.size();
        if (len < 2) return false;

        const char *array = bloom_filter.data();
        const size_t bits = (len - 1) * 8;

        // Use the encoded k so that we can read filters generated by
        // bloom filters created using different parameters.
        const size_t k = array[len - 1];
        if (k > 30) {
            // Reserved for potentially new encodings for short bloom filters.
            // Consider it a match.
            return true;
        }
        std::hash<std::string> hashFunction;
        size_t h = hashFunction(key);
        const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
        for (size_t j = 0; j < k; j++) {
            const uint32_t bitpos = h % bits;
            if ((array[bitpos / 8] & (1 << (bitpos % 8))) == 0) return false;
            h += delta;
        }
        return true;
    }

    void BloomFilter::CombineFilters(std::string& result, const std::string& src) {
        if (result.empty()){
            result = src;
        }

        // Check if the filter sizes are compatible
        if (result.size() != src.size()) {
            return;
        }

        for (size_t i = 0; i < src.size(); i++) {
            result[i] = result[i] | src[i]; // Perform bitwise OR operation
        }
    }

}